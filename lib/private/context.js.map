{"version":3,"sources":["private/context.js","private/context.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAV,EAAmB;AAChB,QAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,OAAO,OAAP,KAAmB,QAA1B,EAAoC;AAClE,YAAI,IAAI,QAAQ,OAAR,EAAiB,OAAjB,CAAJ,CAD8D,IAC3B,MAAM,SAAN,EAAiB,OAAO,OAAP,GAAiB,CAAjB,CAArB;KADvC,MAGK,IAAI,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAP,EAAY;AACjD,eAAO,CAAC,SAAD,EAAY,SAAZ,EAAuB,eAAvB,EAAwC,iBAAxC,EAA2D,eAA3D,CAAP,EAAoF,OAApF,EADiD;KAAhD;CAJR,CAAD,CAOG,UAAU,OAAV,EAAmB,OAAnB,EAA4B;AAC3B,iBAD2B;;ACP/B,UAAA,QAAA,QAAuB,eAAvB,CAAA,CDO+B;ACN/B,UAAA,iBAAA,QAAyC,iBAAzC,CAAA,CDM+B;ACF/B,UAAA,gBAAA,QAAwB,eAAxB,CAAA,CDE+B;ACI/B,QAAI,QAAJ,CDJ+B;ACU/B,aAAA,WAAA,CACC,OADD,EAEC,QAFD,EAGC,SAHD,EAGmB;AAElB,gBAAA,cAAA,GAAiB,OAAjB,CAFkB;AAGlB,gBAAA,WAAA,GAAc,IAAI,cAAA,OAAA,CAAY,QAAhB,CAAd,CAHkB;AAIlB,mBAAW,EAAX,CAJkB;AAMlB,YAAI;AACH,gBAAI,MAAJ,CADG;AAEH,gBAAI;AACH,yBAAS,WAAT,CADG;aAAJ,CAEE,OAAO,KAAP,EAAc;AACf,oBAAI,EAAE,iBAAiB,eAAA,OAAA,CAAnB,EACH,MAAM,KAAN,CADD;AAEA,yBAAS,KAAT,CAHe;aAAd;AAOF,qBAAS,IAAT,CAAc,CAAC,CAAD,EAAI,CAAJ,KAAU,EAAE,GAAF,CAAM,OAAN,CAAc,EAAE,GAAF,CAAxB,CAAd,CAXG;AAYH,mBAAO,EAAC,UAAA,QAAA,EAAU,QAAA,MAAA,EAAlB,CAZG;SAAJ,SAaU;AAET,oBAAA,cAAA,GAAiB,QAAA,WAAA,GAAc,WAAW,IAAX,CAFtB;SAbV;KATD;AAAgB,YAAA,WAAA,GAAW,WAAX,CDVe;AC0C/B,aAAA,KAAA,CACC,IADD,EAEC,GAFD,EAGC,OAHD,EAGiC;AAChC,YAAI,CAAC,IAAD,EACH,MAAM,KAAK,eAAe,QAAf,GAA0B,KAA1B,GAAkC,GAAlC,EAAuC,OAA5C,CAAN,CADD;KAJD;AAAgB,YAAA,KAAA,GAAK,KAAL,CD1Ce;ACmD/B,aAAA,IAAA,CAAqB,GAArB,EAAqC,OAArC,EAAqE;AACpE,eAAO,IAAI,eAAA,OAAA,CAAa,aAAa,GAAb,EAAkB,OAAlB,CAAjB,CAAP,CADoE;KAArE;AAAgB,YAAA,IAAA,GAAI,IAAJ,CDnDe;AC+D/B,aAAA,IAAA,CAAqB,GAArB,EAAqC,OAArC,EAAqE;AACpE,iBAAS,IAAT,CAAc,aAAa,GAAb,EAAkB,OAAlB,CAAd,EADoE;KAArE;AAAgB,YAAA,IAAA,GAAI,IAAJ,CD/De;ACmE/B,aAAA,YAAA,CAAsB,GAAtB,EAAsC,OAAtC,EAAsE;AACrE,cAAM,IAAI,eAAe,MAAA,GAAA,GAAM,MAAA,OAAA,CAAI,UAAJ,CAAe,GAAf,CAArB,GAA2C,GAA3C,CAD2D;AAErE,eAAO,IAAI,eAAA,YAAA,CAAa,CAAjB,EAAoB,QAAQ,QAAA,cAAA,CAAe,QAAf,CAA5B,CAAP,CAFqE;KAAtE;CDnEG,CAPH","file":"private/context.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'esast/lib/Loc', '../CompileError', './PathOptions'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    const Loc_1 = require('esast/lib/Loc');\n    const CompileError_1 = require('../CompileError');\n    const PathOptions_1 = require('./PathOptions');\n    let warnings;\n    function withContext(options, filename, getResult) {\n        exports.compileOptions = options;\n        exports.pathOptions = new PathOptions_1.default(filename);\n        warnings = [];\n        try {\n            let result;\n            try {\n                result = getResult();\n            }\n            catch (error) {\n                if (!(error instanceof CompileError_1.default))\n                    throw error;\n                result = error;\n            }\n            warnings.sort((a, b) => a.loc.compare(b.loc));\n            return { warnings: warnings, result: result };\n        }\n        finally {\n            exports.compileOptions = exports.pathOptions = warnings = null;\n        }\n    }\n    exports.withContext = withContext;\n    function check(cond, loc, message) {\n        if (!cond)\n            throw fail(loc instanceof Function ? loc() : loc, message);\n    }\n    exports.check = check;\n    function fail(loc, message) {\n        return new CompileError_1.default(errorMessage(loc, message));\n    }\n    exports.fail = fail;\n    function warn(loc, message) {\n        warnings.push(errorMessage(loc, message));\n    }\n    exports.warn = warn;\n    function errorMessage(loc, message) {\n        const l = loc instanceof Loc_1.Pos ? Loc_1.default.singleChar(loc) : loc;\n        return new CompileError_1.ErrorMessage(l, message(exports.compileOptions.language));\n    }\n});\n","import Loc, {Pos} from 'esast/lib/Loc'\nimport CompileError, {ErrorMessage} from '../CompileError'\nimport {WarningsAnd} from '../Compiler'\nimport Language from './languages/Language'\nimport CompileOptions from './CompileOptions'\nimport PathOptions from './PathOptions'\n\nexport let compileOptions: CompileOptions\nexport let pathOptions: PathOptions\n\n/** Array of all warnings produced during compilation. */\nlet warnings: Array<ErrorMessage>\n\n/**\n`options` and `pathOptions` will be set while running `getResult`.\nWhen done, returns warnings along with the result.\n*/\nexport function withContext<A>(\n\toptions: CompileOptions,\n\tfilename: string,\n\tgetResult: () => A\n\t): WarningsAnd<A> {\n\tcompileOptions = options\n\tpathOptions = new PathOptions(filename)\n\twarnings = []\n\n\ttry {\n\t\tlet result: A\n\t\ttry {\n\t\t\tresult = getResult()\n\t\t} catch (error) {\n\t\t\tif (!(error instanceof CompileError))\n\t\t\t\tthrow error\n\t\t\tresult = error\n\t\t}\n\n\t\t// Sort warnings to make them easier to read.\n\t\twarnings.sort((a, b) => a.loc.compare(b.loc))\n\t\treturn {warnings, result}\n\t} finally {\n\t\t// Release for garbage collection.\n\t\tcompileOptions = pathOptions = warnings = null\n\t}\n}\n\n/**\nIf `cond` is false, [[fail]].\n`loc` and `message` may also be Functions to to get them lazily.\n*/\nexport function check(\n\tcond: boolean,\n\tloc: Pos | Loc | (() => Pos | Loc),\n\tmessage: (_: Language) => string): void {\n\tif (!cond)\n\t\tthrow fail(loc instanceof Function ? loc() : loc, message)\n}\n\n/** Create a [[CompileError]]. Parameters are the same as for {@link warn}. */\nexport function fail(loc: Pos | Loc, message: (_: Language) => string): CompileError {\n\treturn new CompileError(errorMessage(loc, message))\n}\n\n/**\nAdd a new warning.\n@param code Message code. For a complete list, see [[english]].\n@param args\n\tArguments for rendering the message.\n\tWhen these are supplied, the message handler must be a function.\n\tSee [[english]] for which messages are functions.\n*/\nexport function warn(loc: Loc | Pos, message: (_: Language) => string): void {\n\twarnings.push(errorMessage(loc, message))\n}\n\nfunction errorMessage(loc: Loc | Pos, message: (_: Language) => string): ErrorMessage {\n\tconst l = loc instanceof Pos ? Loc.singleChar(loc) : loc\n\treturn new ErrorMessage(l, message(compileOptions.language))\n}\n"],"sourceRoot":"/source/"}