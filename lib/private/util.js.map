{"version":3,"sources":["private/util.js","private/util.ts"],"names":[],"mappings":"AAAA,CAAC,UAAU,OAAV,EAAmB;AAChB,QAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,OAAO,OAAP,KAAmB,QAA1B,EAAoC;AAClE,YAAI,IAAI,QAAQ,OAAR,EAAiB,OAAjB,CAAJ,CAD8D,IAC3B,MAAM,SAAN,EAAiB,OAAO,OAAP,GAAiB,CAAjB,CAArB;KADvC,MAGK,IAAI,OAAO,MAAP,KAAkB,UAAlB,IAAgC,OAAO,GAAP,EAAY;AACjD,eAAO,CAAC,SAAD,EAAY,SAAZ,EAAuB,OAAvB,CAAP,EAAwC,OAAxC,EADiD;KAAhD;CAJR,CAAD,CAOG,UAAU,OAAV,EAAmB,OAAnB,EAA4B;AAC3B,iBAD2B;;ACP/B,UAAA,OAAA,QAA0B,OAA1B,CAAA,CDO+B;ACJ/B,aAAA,OAAA,CAA8B,KAA9B,EAA+C,MAA/C,EAAkE;AACjE,YAAI,QAAQ,KAAR,CAAJ,EACC,OAAO,IAAP,CADD;AAEA,cAAM,MAAM,OAAO,MAAM,CAAN,CAAP,CAAN,CAH2D;AAIjE,aAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,MAAM,MAAN,EAAc,IAAI,IAAI,CAAJ,EACrC,IAAI,OAAO,MAAM,CAAN,CAAP,MAAqB,GAArB,EACH,OAAO,KAAP,CADD;AAED,eAAO,IAAP,CAPiE;KAAlE;AAAgB,YAAA,OAAA,GAAO,OAAP,CDIe;ACW/B,aAAA,MAAA,CAAuB,IAAvB,EAAoC;AACnC,YAAI,CAAC,IAAD,EACH,MAAM,IAAI,KAAJ,CAAU,mBAAV,CAAN,CADD;KADD;AAAgB,YAAA,MAAA,GAAM,MAAN,CDXe;ACqB/B,aAAA,GAAA,GAAuE;AACtE,cAAM,MAAgB,EAAhB,CADgE;;0CAA7C;;SAA6C;;AAEtE,aAAK,MAAM,CAAN,IAAW,KAAhB,EACC,IAAI,aAAa,KAAb,EACH,IAAI,IAAJ,CAAS,GAAG,CAAH,CAAT,CADD,KAEK,IAAI,KAAA,OAAA,CAAW,CAAX,CAAJ,EACJ,IAAI,IAAJ,CAAS,CAAT,EADI;AAEN,eAAO,GAAP,CAPsE;KAAvE;AAAgB,YAAA,GAAA,GAAG,GAAH,CDrBe;ACmC/B,aAAA,OAAA,CACC,MADD,EAEC,MAFD,EAE2C;AAE1C,cAAM,MAAgB,EAAhB,CAFoC;AAG1C,aAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,OAAO,MAAP,EAAe,IAAI,IAAI,CAAJ,EACtC,IAAI,IAAJ,CAAS,GAAG,OAAO,OAAO,CAAP,CAAP,EAAkB,CAAlB,CAAH,CAAT,CADD;AAEA,eAAO,GAAP,CAL0C;KAF3C;AAAgB,YAAA,OAAA,GAAO,OAAP,CDnCe;AC8C/B,aAAA,IAAA,CAAwB,KAAxB,EAAuC;AACtC,eAAO,CAAC,QAAQ,KAAR,CAAD,CAAP,CADsC;AAEtC,eAAO,MAAM,CAAN,CAAP,CAFsC;KAAvC;AAAgB,YAAA,IAAA,GAAI,IAAJ,CD9Ce;ACoD/B,aAAA,OAAA,CAA2B,KAA3B,EAA0C;AACzC,eAAO,MAAM,MAAN,KAAiB,CAAjB,CADkC;KAA1C;AAAgB,YAAA,OAAA,GAAO,OAAP,CDpDe;ACyD/B,aAAA,IAAA,CAAwB,KAAxB,EAAuC;AACtC,eAAO,CAAC,QAAQ,KAAR,CAAD,CAAP,CADsC;AAEtC,eAAO,MAAM,MAAM,MAAN,GAAe,CAAf,CAAb,CAFsC;KAAvC;AAAgB,YAAA,IAAA,GAAI,IAAJ,CDzDe;AC+D/B,cAAA,WAAA,CAAgC,KAAhC,EAA+C;AAC9C,aAAK,IAAI,IAAI,MAAM,MAAN,GAAe,CAAf,EAAkB,KAAK,CAAL,EAAQ,IAAI,IAAI,CAAJ,EAC1C,MAAM,MAAM,CAAN,CAAN,CADD;KADD;AAAiB,YAAA,WAAA,GAAW,WAAX,CD/Dc;ACqE/B,aAAA,KAAA,CAAyB,KAAzB,EAAwC;AACvC,eAAO,CAAC,QAAQ,KAAR,CAAD,CAAP,CADuC;AAEvC,eAAO,MAAM,KAAN,CAAY,CAAZ,EAAe,MAAM,MAAN,GAAe,CAAf,CAAtB,CAFuC;KAAxC;AAAgB,YAAA,KAAA,GAAK,KAAL,CDrEe;AC2E/B,aAAA,IAAA,CAAwB,KAAxB,EAAuC;AACtC,eAAO,CAAC,QAAQ,KAAR,CAAD,CAAP,CADsC;AAEtC,eAAO,MAAM,KAAN,CAAY,CAAZ,CAAP,CAFsC;KAAvC;AAAgB,YAAA,IAAA,GAAI,IAAJ,CD3Ee;ACiF/B,aAAA,OAAA,CAA2B,KAA3B,EAA8C;AAC7C,eAAO,iBAAiB,KAAjB,GAAyB,KAAzB,GAAiC,CAAC,KAAD,CAAjC,CADsC;KAA9C;AAAgB,YAAA,OAAA,GAAO,OAAP,CDjFe;AC2F/B,aAAA,aAAA,CAAiC,QAAjC,EAA8C,QAA9C,EAAyD;AACxD,cAAM,MAAW,EAAX,CADkD;AAGxD,aAAK,MAAM,GAAN,IAAa,QAAlB,EAA4B;AAC3B,gBAAI,EAAE,OAAO,QAAP,CAAF,EACH,MAAM,IAAI,KAAJ,CAAU,CAAA,eAAA,GAAkB,GAAlB,EAAqB,CAArB,CAAV,CAAN,CADD;AAEA,gBAAI,GAAJ,IAAkB,SAAU,GAAV,CAAlB,CAH2B;SAA5B;AAMA,aAAK,MAAM,GAAN,IAAa,QAAlB,EACC,IAAI,EAAE,OAAO,GAAP,CAAF,EACH,IAAI,GAAJ,IAAkB,SAAU,GAAV,CAAlB,CADD;AAGD,eAAO,GAAP,CAbwD;KAAzD;AAAgB,YAAA,aAAA,GAAa,aAAb,CD3Fe;CAA5B,CAPH","file":"private/util.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'op/Op'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    const Op_1 = require('op/Op');\n    function allSame(array, mapper) {\n        if (isEmpty(array))\n            return true;\n        const val = mapper(array[0]);\n        for (let i = 1; i < array.length; i = i + 1)\n            if (mapper(array[i]) !== val)\n                return false;\n        return true;\n    }\n    exports.allSame = allSame;\n    function assert(cond) {\n        if (!cond)\n            throw new Error('Assertion failed.');\n    }\n    exports.assert = assert;\n    function cat(...parts) {\n        const out = [];\n        for (const _ of parts)\n            if (_ instanceof Array)\n                out.push(..._);\n            else if (Op_1.nonNull(_))\n                out.push(_);\n        return out;\n    }\n    exports.cat = cat;\n    function flatMap(mapped, mapper) {\n        const out = [];\n        for (let i = 0; i < mapped.length; i = i + 1)\n            out.push(...mapper(mapped[i], i));\n        return out;\n    }\n    exports.flatMap = flatMap;\n    function head(array) {\n        assert(!isEmpty(array));\n        return array[0];\n    }\n    exports.head = head;\n    function isEmpty(array) {\n        return array.length === 0;\n    }\n    exports.isEmpty = isEmpty;\n    function last(array) {\n        assert(!isEmpty(array));\n        return array[array.length - 1];\n    }\n    exports.last = last;\n    function* reverseIter(array) {\n        for (let i = array.length - 1; i >= 0; i = i - 1)\n            yield array[i];\n    }\n    exports.reverseIter = reverseIter;\n    function rtail(array) {\n        assert(!isEmpty(array));\n        return array.slice(0, array.length - 1);\n    }\n    exports.rtail = rtail;\n    function tail(array) {\n        assert(!isEmpty(array));\n        return array.slice(1);\n    }\n    exports.tail = tail;\n    function toArray(value) {\n        return value instanceof Array ? value : [value];\n    }\n    exports.toArray = toArray;\n    function applyDefaults(provided, defaults) {\n        const out = {};\n        for (const key in provided) {\n            if (!(key in defaults))\n                throw new Error(`No such option ${key}.`);\n            out[key] = provided[key];\n        }\n        for (const key in defaults)\n            if (!(key in out))\n                out[key] = defaults[key];\n        return out;\n    }\n    exports.applyDefaults = applyDefaults;\n});\n","import Op, {nonNull} from 'op/Op'\n\n/** Whether every element in `array` is equal. */\nexport function allSame<A, B>(array: Array<A>, mapper: (a: A) => B): boolean {\n\tif (isEmpty(array))\n\t\treturn true\n\tconst val = mapper(array[0])\n\tfor (let i = 1; i < array.length; i = i + 1)\n\t\tif (mapper(array[i]) !== val)\n\t\t\treturn false\n\treturn true\n}\n\n/**\nUsed to ensure that the compiler is programmed correctly.\nIf an assertion fails, it's a bug in mason-compile.\nFor errors in source code, see [[check]].\n*/\nexport function assert(cond: boolean): void {\n\tif (!cond)\n\t\tthrow new Error('Assertion failed.')\n}\n\n/**\nCombine many values into one array.\nArrays are flattened and nulls are skipped.\nSo `cat([1, 2], null, 3)` is `[1, 2, 3]`.\n*/\nexport function cat<A>(...parts: Array<Array<A> | Op<A> | Op<Array<A>>>): Array<A> {\n\tconst out: Array<A> = []\n\tfor (const _ of parts)\n\t\tif (_ instanceof Array)\n\t\t\tout.push(..._)\n\t\telse if (nonNull<A>(_))\n\t\t\tout.push(_)\n\treturn out\n}\n\n/**\nLike `Array.prototype.map` but `mapper` should return Arrays,\nwhich are flattened to a single Array.\n*/\nexport function flatMap<A, B>(\n\tmapped: Array<A>,\n\tmapper: (a: A, index?: number) => Array<B>\n\t): Array<B> {\n\tconst out: Array<B> = []\n\tfor (let i = 0; i < mapped.length; i = i + 1)\n\t\tout.push(...mapper(mapped[i], i))\n\treturn out\n}\n\n/** First element of an Array. */\nexport function head<A>(array: Array<A>): A {\n\tassert(!isEmpty(array))\n\treturn array[0]\n}\n\n/** False iff there are any elements in the array. */\nexport function isEmpty<A>(array: Array<A>): boolean {\n\treturn array.length === 0\n}\n\n/** Element at the end of an Array. */\nexport function last<A>(array: Array<A>): A {\n\tassert(!isEmpty(array))\n\treturn array[array.length - 1]\n}\n\n/** Iterate over an Array in reverse. */\nexport function* reverseIter<A>(array: Array<A>): Iterable<A> {\n\tfor (let i = array.length - 1; i >= 0; i = i - 1)\n\t\tyield array[i]\n}\n\n/** All but the last element of an Array. */\nexport function rtail<A>(array: Array<A>): Array<A> {\n\tassert(!isEmpty(array))\n\treturn array.slice(0, array.length - 1)\n}\n\n/** All but the first element of an Array. */\nexport function tail<A>(array: Array<A>): Array<A> {\n\tassert(!isEmpty(array))\n\treturn array.slice(1)\n}\n\n/** Wrap value in an Array if it's not already one. */\nexport function toArray<A>(value: A | Array<A>): Array<A> {\n\treturn value instanceof Array ? value : [value]\n}\n\n/**\nUsed for functions that take an options objects.\nFills in defaults for options not provided.\nThrows errors for provided options that aren't recognized.\nA default value of `undefined` is used to indicate that the option must be provided.\n*/\nexport function applyDefaults<A>(provided: A, defaults: A): A {\n\tconst out: any = {}\n\n\tfor (const key in provided) {\n\t\tif (!(key in defaults))\n\t\t\tthrow new Error(`No such option ${key}.`)\n\t\tout[key] = (<any> provided)[key]\n\t}\n\n\tfor (const key in defaults)\n\t\tif (!(key in out))\n\t\t\tout[key] = (<any> defaults)[key]\n\n\treturn out\n}\n"],"sourceRoot":"/source/"}