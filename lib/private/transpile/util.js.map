{"version":3,"sources":["private/transpile/util.js","private/transpile/util.ts"],"names":[],"mappings":"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","file":"private/transpile/util.js","sourcesContent":["(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", 'esast/lib/Expression', 'esast/lib/Function', 'esast/lib/Literal', 'esast/lib/Statement', 'op/Op', '../context', '../util', './esast-constants', './context', './ms', './transpileDo', './transpileVal'], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    const Expression_1 = require('esast/lib/Expression');\n    const Function_1 = require('esast/lib/Function');\n    const Literal_1 = require('esast/lib/Literal');\n    const Statement_1 = require('esast/lib/Statement');\n    const Op_1 = require('op/Op');\n    const context_1 = require('../context');\n    const util_1 = require('../util');\n    const esast_constants_1 = require('./esast-constants');\n    const context_2 = require('./context');\n    const ms_1 = require('./ms');\n    const transpileDo_1 = require('./transpileDo');\n    const transpileVal_1 = require('./transpileVal');\n    function loc(expr, node) {\n        util_1.assert(node.loc === undefined);\n        node.loc = expr.loc;\n        return node;\n    }\n    exports.loc = loc;\n    function transpileLines(exprs) {\n        const out = [];\n        for (const expr of exprs) {\n            const ast = transpileDo_1.default(expr);\n            if (ast instanceof Array)\n                for (const _ of ast)\n                    out.push(_);\n            else\n                out.push(ast);\n        }\n        return out;\n    }\n    exports.transpileLines = transpileLines;\n    function maybeWrapInCheckInstance(ast, opType, name) {\n        return context_1.compileOptions.checks && Op_1.nonNull(opType) ?\n            ms_1.msCall('checkInstance', transpileVal_1.default(opType), ast, new Literal_1.LiteralString(name)) :\n            ast;\n    }\n    exports.maybeWrapInCheckInstance = maybeWrapInCheckInstance;\n    function lazyWrap(value) {\n        return ms_1.msCall('lazy', new Function_1.ArrowFunctionExpression([], value));\n    }\n    exports.lazyWrap = lazyWrap;\n    function callFocusFun(value, calledOn) {\n        const fun = context_2.funKind === 0 ?\n            new Function_1.ArrowFunctionExpression([esast_constants_1.idFocus], value) :\n            new Function_1.FunctionExpression(null, [esast_constants_1.idFocus], new Statement_1.BlockStatement([new Statement_1.ReturnStatement(value)]), { generator: true });\n        return callPreservingFunKind(new Expression_1.CallExpression(fun, [calledOn]));\n    }\n    exports.callFocusFun = callFocusFun;\n    function callPreservingFunKind(call) {\n        return context_2.funKind === 0 ? call : new Expression_1.YieldDelegateExpression(call);\n    }\n    exports.callPreservingFunKind = callPreservingFunKind;\n});\n","import Expression, {CallExpression, YieldDelegateExpression} from 'esast/lib/Expression'\nimport {ArrowFunctionExpression, FunctionExpression} from 'esast/lib/Function'\nimport {LiteralString} from 'esast/lib/Literal'\nimport Node from 'esast/lib/Node'\nimport Statement, {BlockStatement, ReturnStatement} from 'esast/lib/Statement'\nimport Op, {nonNull} from 'op/Op'\nimport {compileOptions} from '../context'\nimport {Funs} from '../ast/Fun'\nimport {Do, Val} from '../ast/LineContent'\nimport MsAst from '../ast/MsAst'\nimport {assert} from '../util'\nimport {idFocus} from './esast-constants'\nimport {funKind} from './context'\nimport {msCall} from './ms'\nimport transpileDo from './transpileDo'\nimport transpileVal from './transpileVal'\n\n/** Set `node`'s loc and return it. */\nexport function loc<A extends Node>(expr: MsAst, node: A): A {\n\tassert(node.loc === undefined)\n\tnode.loc = expr.loc\n\treturn node\n}\n\n/** Transpile many lines to many statements. */\nexport function transpileLines(exprs: Array<Do>): Array<Statement> {\n\tconst out: Array<Statement> = []\n\tfor (const expr of exprs) {\n\t\tconst ast = transpileDo(expr)\n\t\tif (ast instanceof Array)\n\t\t\tfor (const _ of ast)\n\t\t\t\tout.push(_)\n\t\telse\n\t\t\tout.push(ast)\n\t}\n\treturn out\n}\n\n/**\nWrap `ast` in `_ms.checkInstance(...)` if the type exists.\n@param name Name used for `ast`. Used in for error reporting if the type check fails.\n*/\nexport function maybeWrapInCheckInstance(\n\tast: Expression,\n\topType: Op<Val>,\n\tname: string)\n\t: Expression {\n\treturn compileOptions.checks && nonNull(opType) ?\n\t\tmsCall('checkInstance', transpileVal(opType), ast, new LiteralString(name)) :\n\t\tast\n}\n\n/** Wrap an expression to be lazily evaluated. */\nexport function lazyWrap(value: Expression): Expression {\n\treturn msCall('lazy', new ArrowFunctionExpression([], value))\n}\n\n/** Create a focus fun returning `value` and call it on `calledOn`, preserving generator/async. */\nexport function callFocusFun(value: Expression, calledOn: Expression): Expression {\n\tconst fun = funKind === Funs.Plain ?\n\t\tnew ArrowFunctionExpression([idFocus], value) :\n\t\tnew FunctionExpression(\n\t\t\tnull, [idFocus], new BlockStatement([new ReturnStatement(value)]), {generator: true})\n\treturn callPreservingFunKind(new CallExpression(fun, [calledOn]))\n}\n\n/**\nCall a function created by `blockWrap` or `callFocusFun`.\nThis looks like:\n\tFuns.Plain: `(_ => foo(_))(1)`.\n\tFuns.Generator, Funs.Async: `yield* function*(_) { return foo(_) }(1)`\n*/\nexport function callPreservingFunKind(call: Expression): Expression {\n\treturn funKind === Funs.Plain ? call : new YieldDelegateExpression(call)\n}\n"],"sourceRoot":"/source/"}